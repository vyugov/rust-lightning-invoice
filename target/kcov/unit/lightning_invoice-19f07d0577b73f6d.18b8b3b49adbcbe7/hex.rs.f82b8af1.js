var data = {lines:[
{"lineNum":"    1","line":"// Bitcoin Hashes Library"},
{"lineNum":"    2","line":"// Written in 2018 by"},
{"lineNum":"    3","line":"//   Andrew Poelstra <apoelstra@wpsoftware.net>"},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"// To the extent possible under law, the author(s) have dedicated all"},
{"lineNum":"    6","line":"// copyright and related and neighboring rights to this software to"},
{"lineNum":"    7","line":"// the public domain worldwide. This software is distributed without"},
{"lineNum":"    8","line":"// any warranty."},
{"lineNum":"    9","line":"//"},
{"lineNum":"   10","line":"// You should have received a copy of the CC0 Public Domain Dedication"},
{"lineNum":"   11","line":"// along with this software."},
{"lineNum":"   12","line":"// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>."},
{"lineNum":"   13","line":"//"},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"//! # Hex encoding and decoding"},
{"lineNum":"   16","line":"//!"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"use std::fmt;"},
{"lineNum":"   19","line":"use {Error, Hash};"},
{"lineNum":"   20","line":""},
{"lineNum":"   21","line":"/// Trait for objects that can be serialized as hex strings"},
{"lineNum":"   22","line":"pub trait ToHex {"},
{"lineNum":"   23","line":"    /// Hex representation of the object"},
{"lineNum":"   24","line":"    fn to_hex(&self) -> String;"},
{"lineNum":"   25","line":"}"},
{"lineNum":"   26","line":""},
{"lineNum":"   27","line":"/// Trait for objects that can be deserialized from hex strings"},
{"lineNum":"   28","line":"pub trait FromHex: Sized {"},
{"lineNum":"   29","line":"    /// Produce an object from a hex string"},
{"lineNum":"   30","line":"    fn from_hex(s: &str) -> Result<Self, Error>;"},
{"lineNum":"   31","line":"}"},
{"lineNum":"   32","line":""},
{"lineNum":"   33","line":"impl<T: fmt::LowerHex> ToHex for T {"},
{"lineNum":"   34","line":"    /// Outputs the hash in hexadecimal form"},
{"lineNum":"   35","line":"    fn to_hex(&self) -> String {"},
{"lineNum":"   36","line":"        format!(\"{:x}\", self)"},
{"lineNum":"   37","line":"    }"},
{"lineNum":"   38","line":"}"},
{"lineNum":"   39","line":""},
{"lineNum":"   40","line":"impl<T: Hash> FromHex for T {"},
{"lineNum":"   41","line":"    /// Parses a hex string as a hash object"},
{"lineNum":"   42","line":"    fn from_hex(s: &str) -> Result<Self, Error> {","class":"linePartCov","hits":"1","order":"2749","possible_hits":"2",},
{"lineNum":"   43","line":"        if s.len() != 2 * Self::LEN {","class":"linePartCov","hits":"2","order":"2750","possible_hits":"3",},
{"lineNum":"   44","line":"            return Err(Error::InvalidLength(2 * Self::LEN, s.len()));","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   45","line":"        }"},
{"lineNum":"   46","line":""},
{"lineNum":"   47","line":"        let mut vec = Vec::<u8>::from_hex(s)?;","class":"linePartCov","hits":"2","order":"2754","possible_hits":"4",},
{"lineNum":"   48","line":"        if Self::DISPLAY_BACKWARD {","class":"linePartCov","hits":"1","order":"2843","possible_hits":"2",},
{"lineNum":"   49","line":"            vec.reverse();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   50","line":"        }"},
{"lineNum":"   51","line":"        Self::from_slice(&vec)","class":"lineCov","hits":"1","order":"2844","possible_hits":"1",},
{"lineNum":"   52","line":"    }","class":"linePartCov","hits":"2","order":"2851","possible_hits":"4",},
{"lineNum":"   53","line":"}"},
{"lineNum":"   54","line":""},
{"lineNum":"   55","line":"/// Iterator over a hex-encoded string slice which decodes hex and yields bytes."},
{"lineNum":"   56","line":"pub struct HexIterator<\'a> {"},
{"lineNum":"   57","line":"    /// The slice whose first two characters will be decoded to yield the next byte"},
{"lineNum":"   58","line":"    pub sl: &\'a str"},
{"lineNum":"   59","line":"}"},
{"lineNum":"   60","line":""},
{"lineNum":"   61","line":"impl<\'a> Iterator for HexIterator<\'a> {"},
{"lineNum":"   62","line":"    type Item = Result<u8, Error>;"},
{"lineNum":"   63","line":""},
{"lineNum":"   64","line":"    fn next(&mut self) -> Option<Result<u8, Error>> {","class":"lineCov","hits":"1","order":"2761","possible_hits":"1",},
{"lineNum":"   65","line":"        if self.sl.len() % 2 == 1 {","class":"linePartCov","hits":"2","order":"2762","possible_hits":"3",},
{"lineNum":"   66","line":"            Some(Err(Error::OddLengthString(self.sl.len())))","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   67","line":"        } else if self.sl.is_empty() {","class":"lineCov","hits":"3","order":"2763","possible_hits":"3",},
{"lineNum":"   68","line":"            None","class":"lineCov","hits":"1","order":"2840","possible_hits":"1",},
{"lineNum":"   69","line":"        } else {"},
{"lineNum":"   70","line":"            let (hi, lo) = {","class":"lineCov","hits":"1","order":"2800","possible_hits":"1",},
{"lineNum":"   71","line":"                let mut iter = self.sl.chars();","class":"lineCov","hits":"1","order":"2767","possible_hits":"1",},
{"lineNum":"   72","line":"                let hi = iter.next().unwrap();","class":"lineCov","hits":"1","order":"2771","possible_hits":"1",},
{"lineNum":"   73","line":"                let lo = iter.next().unwrap();","class":"lineCov","hits":"1","order":"2790","possible_hits":"1",},
{"lineNum":"   74","line":"                match (hi.to_digit(16), lo.to_digit(16)) {","class":"linePartCov","hits":"1","order":"2791","possible_hits":"2",},
{"lineNum":"   75","line":"                    (Some(hi), Some(lo)) => (hi, lo),","class":"lineCov","hits":"2","order":"2799","possible_hits":"2",},
{"lineNum":"   76","line":"                    (None, _) => return Some(Err(Error::InvalidChar(hi))),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   77","line":"                    (_, None) => return Some(Err(Error::InvalidChar(lo))),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   78","line":"                }"},
{"lineNum":"   79","line":"            };"},
{"lineNum":"   80","line":"            let ret = (hi << 4) + lo;","class":"linePartCov","hits":"2","order":"2801","possible_hits":"4",},
{"lineNum":"   81","line":"            self.sl = &self.sl[2..];","class":"lineCov","hits":"1","order":"2802","possible_hits":"1",},
{"lineNum":"   82","line":"            Some(Ok(ret as u8))","class":"lineCov","hits":"1","order":"2837","possible_hits":"1",},
{"lineNum":"   83","line":"        }"},
{"lineNum":"   84","line":"    }","class":"linePartCov","hits":"2","order":"2838","possible_hits":"3",},
{"lineNum":"   85","line":"}"},
{"lineNum":"   86","line":""},
{"lineNum":"   87","line":"/// Output hex into an object implementing `fmt::Write`, which is usually more"},
{"lineNum":"   88","line":"/// efficient than going through a `String` using `ToHex`."},
{"lineNum":"   89","line":"pub fn format_hex<T: fmt::Write>(data: &[u8], mut fmt: T) -> fmt::Result {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   90","line":"    for ch in data {","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"   91","line":"        write!(fmt, \"{:02x}\", *ch)?;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   92","line":"    }"},
{"lineNum":"   93","line":"    Ok(())","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   94","line":"}","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"   95","line":""},
{"lineNum":"   96","line":"/// Output hex in reverse order; used for Sha256dHash whose standard hex encoding"},
{"lineNum":"   97","line":"/// has the bytes reversed."},
{"lineNum":"   98","line":"pub fn format_hex_reverse<T: fmt::Write>(data: &[u8], mut fmt: T) -> fmt::Result {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   99","line":"    for ch in data.iter().rev() {","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  100","line":"        write!(fmt, \"{:02x}\", *ch)?;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  101","line":"    }"},
{"lineNum":"  102","line":"    Ok(())","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  103","line":"}","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  104","line":""},
{"lineNum":"  105","line":"impl ToHex for [u8] {"},
{"lineNum":"  106","line":"    fn to_hex(&self) -> String {"},
{"lineNum":"  107","line":"        let mut ret = String::with_capacity(2 * self.len());"},
{"lineNum":"  108","line":"        format_hex(self, &mut ret).expect(\"format to string\");"},
{"lineNum":"  109","line":"        ret"},
{"lineNum":"  110","line":"    }"},
{"lineNum":"  111","line":"}"},
{"lineNum":"  112","line":""},
{"lineNum":"  113","line":"impl FromHex for Vec<u8> {"},
{"lineNum":"  114","line":"    fn from_hex(s: &str) -> Result<Vec<u8>, Error> {","class":"linePartCov","hits":"1","order":"2755","possible_hits":"2",},
{"lineNum":"  115","line":"        if s.len() % 2 == 1 {","class":"lineCov","hits":"2","order":"2756","possible_hits":"2",},
{"lineNum":"  116","line":"            return Err(Error::OddLengthString(s.len()));","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  117","line":"        }"},
{"lineNum":"  118","line":""},
{"lineNum":"  119","line":"        let mut vec = Vec::with_capacity(s.len() / 2);","class":"lineCov","hits":"2","order":"2757","possible_hits":"2",},
{"lineNum":"  120","line":"        let iter = HexIterator {","class":"lineCov","hits":"1","order":"2759","possible_hits":"1",},
{"lineNum":"  121","line":"            sl: s","class":"lineCov","hits":"1","order":"2758","possible_hits":"1",},
{"lineNum":"  122","line":"        };"},
{"lineNum":"  123","line":"        for byte in iter {","class":"lineCov","hits":"4","order":"2760","possible_hits":"4",},
{"lineNum":"  124","line":"            vec.push(byte?);","class":"linePartCov","hits":"2","order":"2839","possible_hits":"3",},
{"lineNum":"  125","line":"        }"},
{"lineNum":"  126","line":"        Ok(vec)","class":"lineCov","hits":"1","order":"2841","possible_hits":"1",},
{"lineNum":"  127","line":"    }","class":"linePartCov","hits":"2","order":"2842","possible_hits":"5",},
{"lineNum":"  128","line":"}"},
{"lineNum":"  129","line":""},
{"lineNum":"  130","line":"macro_rules! impl_fromhex_array {"},
{"lineNum":"  131","line":"    ($len:expr) => {"},
{"lineNum":"  132","line":"        impl FromHex for [u8; $len] {"},
{"lineNum":"  133","line":"            fn from_hex(s: &str) -> Result<[u8; $len], Error> {"},
{"lineNum":"  134","line":"                if s.len() == 2 * $len {"},
{"lineNum":"  135","line":"                    let mut ret = [0; $len];"},
{"lineNum":"  136","line":"                    let iter = HexIterator {"},
{"lineNum":"  137","line":"                        sl: s,"},
{"lineNum":"  138","line":"                    };"},
{"lineNum":"  139","line":"                    for (n, byte) in iter.enumerate() {"},
{"lineNum":"  140","line":"                        ret[n] = byte?;"},
{"lineNum":"  141","line":"                    }"},
{"lineNum":"  142","line":"                    Ok(ret)"},
{"lineNum":"  143","line":"                } else {"},
{"lineNum":"  144","line":"                    if s.len() % 2 == 1 {"},
{"lineNum":"  145","line":"                        Err(Error::OddLengthString(s.len()))"},
{"lineNum":"  146","line":"                    } else {"},
{"lineNum":"  147","line":"                        Err(Error::InvalidLength(2 * $len, s.len()))"},
{"lineNum":"  148","line":"                    }"},
{"lineNum":"  149","line":"                }"},
{"lineNum":"  150","line":"            }"},
{"lineNum":"  151","line":"        }"},
{"lineNum":"  152","line":"    }"},
{"lineNum":"  153","line":"}"},
{"lineNum":"  154","line":""},
{"lineNum":"  155","line":"impl_fromhex_array!(2);"},
{"lineNum":"  156","line":"impl_fromhex_array!(4);"},
{"lineNum":"  157","line":"impl_fromhex_array!(6);"},
{"lineNum":"  158","line":"impl_fromhex_array!(8);"},
{"lineNum":"  159","line":"impl_fromhex_array!(10);"},
{"lineNum":"  160","line":"impl_fromhex_array!(12);"},
{"lineNum":"  161","line":"impl_fromhex_array!(14);"},
{"lineNum":"  162","line":"impl_fromhex_array!(16);"},
{"lineNum":"  163","line":"impl_fromhex_array!(20);"},
{"lineNum":"  164","line":"impl_fromhex_array!(24);"},
{"lineNum":"  165","line":"impl_fromhex_array!(28);"},
{"lineNum":"  166","line":"impl_fromhex_array!(32);"},
{"lineNum":"  167","line":"impl_fromhex_array!(33);"},
{"lineNum":"  168","line":"impl_fromhex_array!(64);"},
{"lineNum":"  169","line":"impl_fromhex_array!(65);"},
{"lineNum":"  170","line":"impl_fromhex_array!(128);"},
{"lineNum":"  171","line":"impl_fromhex_array!(256);"},
{"lineNum":"  172","line":"impl_fromhex_array!(384);"},
{"lineNum":"  173","line":"impl_fromhex_array!(512);"},
{"lineNum":"  174","line":""},
{"lineNum":"  175","line":"#[cfg(test)]"},
{"lineNum":"  176","line":"mod tests {"},
{"lineNum":"  177","line":"    use super::{ToHex, FromHex};"},
{"lineNum":"  178","line":"    use Error;"},
{"lineNum":"  179","line":""},
{"lineNum":"  180","line":"    #[test]"},
{"lineNum":"  181","line":"    fn hex_roundtrip() {"},
{"lineNum":"  182","line":"        let expected = \"0123456789abcdef\";"},
{"lineNum":"  183","line":"        let expected_up = \"0123456789ABCDEF\";"},
{"lineNum":"  184","line":""},
{"lineNum":"  185","line":"        let parse: Vec<u8> = FromHex::from_hex(expected).expect(\"parse lowercase string\");"},
{"lineNum":"  186","line":"        assert_eq!(parse, vec![0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]);"},
{"lineNum":"  187","line":"        let ser = parse.to_hex();"},
{"lineNum":"  188","line":"        assert_eq!(ser, expected);"},
{"lineNum":"  189","line":""},
{"lineNum":"  190","line":"        let parse: Vec<u8> = FromHex::from_hex(expected_up).expect(\"parse uppercase string\");"},
{"lineNum":"  191","line":"        assert_eq!(parse, vec![0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]);"},
{"lineNum":"  192","line":"        let ser = parse.to_hex();"},
{"lineNum":"  193","line":"        assert_eq!(ser, expected);"},
{"lineNum":"  194","line":""},
{"lineNum":"  195","line":"        let parse: [u8; 8] = FromHex::from_hex(expected_up).expect(\"parse uppercase string\");"},
{"lineNum":"  196","line":"        assert_eq!(parse, [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]);"},
{"lineNum":"  197","line":"        let ser = parse.to_hex();"},
{"lineNum":"  198","line":"        assert_eq!(ser, expected);"},
{"lineNum":"  199","line":"    }"},
{"lineNum":"  200","line":""},
{"lineNum":"  201","line":"    #[test]"},
{"lineNum":"  202","line":"    fn hex_error() {"},
{"lineNum":"  203","line":"        let oddlen = \"0123456789abcdef0\";"},
{"lineNum":"  204","line":"        let badchar1 = \"Z123456789abcdef\";"},
{"lineNum":"  205","line":"        let badchar2 = \"012Y456789abcdeb\";"},
{"lineNum":"  206","line":"        let badchar3 = \"«23456789abcdef\";"},
{"lineNum":"  207","line":""},
{"lineNum":"  208","line":"        assert_eq!("},
{"lineNum":"  209","line":"            Vec::<u8>::from_hex(oddlen),"},
{"lineNum":"  210","line":"            Err(Error::OddLengthString(17))"},
{"lineNum":"  211","line":"        );"},
{"lineNum":"  212","line":"        assert_eq!("},
{"lineNum":"  213","line":"            <[u8; 4]>::from_hex(oddlen),"},
{"lineNum":"  214","line":"            Err(Error::OddLengthString(17))"},
{"lineNum":"  215","line":"        );"},
{"lineNum":"  216","line":"        assert_eq!("},
{"lineNum":"  217","line":"            <[u8; 8]>::from_hex(oddlen),"},
{"lineNum":"  218","line":"            Err(Error::OddLengthString(17))"},
{"lineNum":"  219","line":"        );"},
{"lineNum":"  220","line":"        assert_eq!("},
{"lineNum":"  221","line":"            Vec::<u8>::from_hex(badchar1),"},
{"lineNum":"  222","line":"            Err(Error::InvalidChar(\'Z\'))"},
{"lineNum":"  223","line":"        );"},
{"lineNum":"  224","line":"        assert_eq!("},
{"lineNum":"  225","line":"            Vec::<u8>::from_hex(badchar2),"},
{"lineNum":"  226","line":"            Err(Error::InvalidChar(\'Y\'))"},
{"lineNum":"  227","line":"        );"},
{"lineNum":"  228","line":"        assert_eq!("},
{"lineNum":"  229","line":"            Vec::<u8>::from_hex(badchar3),"},
{"lineNum":"  230","line":"            Err(Error::InvalidChar(\'«\'))"},
{"lineNum":"  231","line":"        );"},
{"lineNum":"  232","line":"    }"},
{"lineNum":"  233","line":"}"},
{"lineNum":"  234","line":""},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "lightning_invoice-19f07d0577b73f6d", "date" : "2019-06-01 07:50:27", "instrumented" : 45, "covered" : 29,};
var merged_data = [];
