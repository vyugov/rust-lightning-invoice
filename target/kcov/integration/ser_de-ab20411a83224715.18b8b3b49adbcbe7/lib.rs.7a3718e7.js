var data = {lines:[
{"lineNum":"    1","line":"// Copyright (c) 2017 Clark Moody","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"    2","line":"//"},
{"lineNum":"    3","line":"// Permission is hereby granted, free of charge, to any person obtaining a copy"},
{"lineNum":"    4","line":"// of this software and associated documentation files (the \"Software\"), to deal"},
{"lineNum":"    5","line":"// in the Software without restriction, including without limitation the rights"},
{"lineNum":"    6","line":"// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell"},
{"lineNum":"    7","line":"// copies of the Software, and to permit persons to whom the Software is"},
{"lineNum":"    8","line":"// furnished to do so, subject to the following conditions:"},
{"lineNum":"    9","line":"//"},
{"lineNum":"   10","line":"// The above copyright notice and this permission notice shall be included in"},
{"lineNum":"   11","line":"// all copies or substantial portions of the Software."},
{"lineNum":"   12","line":"//"},
{"lineNum":"   13","line":"// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR"},
{"lineNum":"   14","line":"// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,"},
{"lineNum":"   15","line":"// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE"},
{"lineNum":"   16","line":"// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER"},
{"lineNum":"   17","line":"// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,"},
{"lineNum":"   18","line":"// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN"},
{"lineNum":"   19","line":"// THE SOFTWARE."},
{"lineNum":"   20","line":""},
{"lineNum":"   21","line":"//! Encoding and decoding Bech32 format"},
{"lineNum":"   22","line":"//!"},
{"lineNum":"   23","line":"//! Bech32 is a 5-bit (base-32) encoding scheme that produces strings that comprise"},
{"lineNum":"   24","line":"//! a human-readable part, a separator, a data part, and a checksum. The encoding"},
{"lineNum":"   25","line":"//! implements a BCH code that guarantees error detection of up to four characters"},
{"lineNum":"   26","line":"//! with less than 1 in 1 billion chance of failing to detect more errors."},
{"lineNum":"   27","line":"//!"},
{"lineNum":"   28","line":"//! The Bech32 encoding was originally formulated in [BIP-0173](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki)"},
{"lineNum":"   29","line":"//!"},
{"lineNum":"   30","line":"//! # Examples"},
{"lineNum":"   31","line":"//!"},
{"lineNum":"   32","line":"//! ```rust"},
{"lineNum":"   33","line":"//! use bech32::Bech32;"},
{"lineNum":"   34","line":"//!"},
{"lineNum":"   35","line":"//! let b = Bech32::new_check_data(\"bech32\".into(), vec![0x00, 0x01, 0x02]).unwrap();"},
{"lineNum":"   36","line":"//! let encoded = b.to_string();"},
{"lineNum":"   37","line":"//! assert_eq!(encoded, \"bech321qpz4nc4pe\".to_string());"},
{"lineNum":"   38","line":"//!"},
{"lineNum":"   39","line":"//! let c = encoded.parse::<Bech32>();"},
{"lineNum":"   40","line":"//! assert_eq!(b, c.unwrap());"},
{"lineNum":"   41","line":"//! ```"},
{"lineNum":"   42","line":"//!"},
{"lineNum":"   43","line":"//! If the data is already range-checked the `Bech32::new` function can be used which will never"},
{"lineNum":"   44","line":"//! return `Err(Error::InvalidData)`."},
{"lineNum":"   45","line":"//!"},
{"lineNum":"   46","line":"//! ```rust"},
{"lineNum":"   47","line":"//! use bech32::{Bech32, u5, ToBase32};"},
{"lineNum":"   48","line":"//!"},
{"lineNum":"   49","line":"//! // converts base256 data to base32 and adds padding if needed"},
{"lineNum":"   50","line":"//! let checked_data: Vec<u5> = [0xb4, 0xff, 0xa5].to_base32();"},
{"lineNum":"   51","line":"//!"},
{"lineNum":"   52","line":"//! let b = Bech32::new(\"bech32\".into(), checked_data).expect(\"hrp is not empty\");"},
{"lineNum":"   53","line":"//! let encoded = b.to_string();"},
{"lineNum":"   54","line":"//!"},
{"lineNum":"   55","line":"//! assert_eq!(encoded, \"bech321knl623tk6v7\".to_string());"},
{"lineNum":"   56","line":"//! ```"},
{"lineNum":"   57","line":"//!"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"#![deny(missing_docs)]"},
{"lineNum":"   60","line":"#![deny(non_upper_case_globals)]"},
{"lineNum":"   61","line":"#![deny(non_camel_case_types)]"},
{"lineNum":"   62","line":"#![deny(non_snake_case)]"},
{"lineNum":"   63","line":"#![deny(unused_mut)]"},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":"#![cfg_attr(feature = \"strict\", deny(warnings))]"},
{"lineNum":"   66","line":""},
{"lineNum":"   67","line":"use std::{error, fmt};"},
{"lineNum":"   68","line":""},
{"lineNum":"   69","line":"// AsciiExt is needed for Rust 1.14 but not for newer versions"},
{"lineNum":"   70","line":"#[allow(unused_imports, deprecated)]"},
{"lineNum":"   71","line":"use std::ascii::AsciiExt;"},
{"lineNum":"   72","line":"use std::fmt::{Display, Formatter};"},
{"lineNum":"   73","line":"use std::str::FromStr;"},
{"lineNum":"   74","line":""},
{"lineNum":"   75","line":"/// Integer in the range `0..32`"},
{"lineNum":"   76","line":"#[derive(PartialEq, Eq, Debug, Copy, Clone, Default, PartialOrd, Ord, Hash)]","class":"linePartCov","hits":"2","order":"2779","possible_hits":"10",},
{"lineNum":"   77","line":"#[allow(non_camel_case_types)]"},
{"lineNum":"   78","line":"pub struct u5(u8);","class":"linePartCov","hits":"1","order":"2780","possible_hits":"4",},
{"lineNum":"   79","line":""},
{"lineNum":"   80","line":"/// Parse/convert base32 slice to `Self`. It is the reciprocal of"},
{"lineNum":"   81","line":"/// `ToBase32`."},
{"lineNum":"   82","line":"pub trait FromBase32: Sized {"},
{"lineNum":"   83","line":"    /// The associated error which can be returned from parsing (e.g. because of bad padding)."},
{"lineNum":"   84","line":"    type Err;"},
{"lineNum":"   85","line":""},
{"lineNum":"   86","line":"    /// Convert a base32 slice to `Self`."},
{"lineNum":"   87","line":"    fn from_base32(b32: &[u5]) -> Result<Self, Self::Err>;"},
{"lineNum":"   88","line":"}"},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"/// A trait for converting a value to a type `T` that represents a `u5` slice."},
{"lineNum":"   91","line":"pub trait ToBase32<T: AsRef<[u5]>> {"},
{"lineNum":"   92","line":"    /// Convert `Self` to base32 slice"},
{"lineNum":"   93","line":"    fn to_base32(&self) -> T;"},
{"lineNum":"   94","line":"}"},
{"lineNum":"   95","line":""},
{"lineNum":"   96","line":"/// A trait to convert between u8 arrays and u5 arrays without changing the content of the elements,"},
{"lineNum":"   97","line":"/// but checking that they are in range."},
{"lineNum":"   98","line":"pub trait CheckBase32<T: AsRef<[u5]>> {"},
{"lineNum":"   99","line":"    /// Error type if conversion fails"},
{"lineNum":"  100","line":"    type Err;"},
{"lineNum":"  101","line":""},
{"lineNum":"  102","line":"    /// Check if all values are in range and return array-like struct of `u5` values"},
{"lineNum":"  103","line":"    fn check_base32(self) -> Result<T, Self::Err>;"},
{"lineNum":"  104","line":"}"},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":"/// Grouping structure for the human-readable part and the data part"},
{"lineNum":"  107","line":"/// of decoded Bech32 string."},
{"lineNum":"  108","line":"///"},
{"lineNum":"  109","line":"/// Please note that in contrast to the standard this library does not"},
{"lineNum":"  110","line":"/// enforce a maximum length for bech32 encoded data. Please make sure to stay inside the parameters"},
{"lineNum":"  111","line":"/// to ensure error detection."},
{"lineNum":"  112","line":"#[derive(PartialEq, Eq, Debug, Clone, PartialOrd, Ord, Hash)]"},
{"lineNum":"  113","line":"pub struct Bech32 {"},
{"lineNum":"  114","line":"    /// Human-readable part"},
{"lineNum":"  115","line":"    hrp: String,"},
{"lineNum":"  116","line":"    /// Data payload"},
{"lineNum":"  117","line":"    data: Vec<u5>"},
{"lineNum":"  118","line":"}"},
{"lineNum":"  119","line":""},
{"lineNum":"  120","line":"impl u5 {"},
{"lineNum":"  121","line":"    /// Convert a `u8` to `u5` if in range, return `Error` otherwise"},
{"lineNum":"  122","line":"    pub fn try_from_u8(value: u8) -> Result<u5, Error> {","class":"lineCov","hits":"1","order":"2141","possible_hits":"1",},
{"lineNum":"  123","line":"        if value > 31 {","class":"linePartCov","hits":"1","order":"2142","possible_hits":"2",},
{"lineNum":"  124","line":"            Err(Error::InvalidData(value))","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  125","line":"        } else {"},
{"lineNum":"  126","line":"            Ok(u5(value))","class":"lineCov","hits":"1","order":"2143","possible_hits":"1",},
{"lineNum":"  127","line":"        }"},
{"lineNum":"  128","line":"    }","class":"linePartCov","hits":"1","order":"2144","possible_hits":"2",},
{"lineNum":"  129","line":""},
{"lineNum":"  130","line":"    /// Returns a copy of the underlying `u8` value"},
{"lineNum":"  131","line":"    pub fn to_u8(&self) -> u8 {","class":"lineCov","hits":"1","order":"3617","possible_hits":"1",},
{"lineNum":"  132","line":"        self.0","class":"lineCov","hits":"1","order":"3618","possible_hits":"1",},
{"lineNum":"  133","line":"    }","class":"linePartCov","hits":"1","order":"3619","possible_hits":"2",},
{"lineNum":"  134","line":"}"},
{"lineNum":"  135","line":""},
{"lineNum":"  136","line":"impl Into<u8> for u5 {"},
{"lineNum":"  137","line":"    fn into(self) -> u8 {","class":"lineCov","hits":"1","order":"2339","possible_hits":"1",},
{"lineNum":"  138","line":"        self.0","class":"lineCov","hits":"1","order":"2340","possible_hits":"1",},
{"lineNum":"  139","line":"    }","class":"linePartCov","hits":"1","order":"2341","possible_hits":"2",},
{"lineNum":"  140","line":"}"},
{"lineNum":"  141","line":""},
{"lineNum":"  142","line":"impl AsRef<u8> for u5 {"},
{"lineNum":"  143","line":"    fn as_ref(&self) -> &u8 {","class":"lineCov","hits":"1","order":"2967","possible_hits":"1",},
{"lineNum":"  144","line":"        &self.0","class":"lineCov","hits":"1","order":"2968","possible_hits":"1",},
{"lineNum":"  145","line":"    }","class":"linePartCov","hits":"1","order":"2969","possible_hits":"2",},
{"lineNum":"  146","line":"}"},
{"lineNum":"  147","line":""},
{"lineNum":"  148","line":"impl<\'f, T: AsRef<[u8]>> CheckBase32<Vec<u5>> for T {"},
{"lineNum":"  149","line":"    type Err = Error;"},
{"lineNum":"  150","line":""},
{"lineNum":"  151","line":"    fn check_base32(self) -> Result<Vec<u5>, Self::Err> {","class":"linePartCov","hits":"1","order":"2260","possible_hits":"2",},
{"lineNum":"  152","line":"        self.as_ref().iter().map(|x| u5::try_from_u8(*x)).collect::<Result<Vec<u5>, Error>>()","class":"lineCov","hits":"5","order":"2261","possible_hits":"5",},
{"lineNum":"  153","line":"    }","class":"linePartCov","hits":"1","order":"2301","possible_hits":"2",},
{"lineNum":"  154","line":"}"},
{"lineNum":"  155","line":""},
{"lineNum":"  156","line":"impl FromBase32 for Vec<u8> {"},
{"lineNum":"  157","line":"    type Err = Error;"},
{"lineNum":"  158","line":""},
{"lineNum":"  159","line":"    /// Convert base32 to base256, removes null-padding if present, returns"},
{"lineNum":"  160","line":"    /// `Err(Error::InvalidPadding)` if padding bits are unequal `0`"},
{"lineNum":"  161","line":"    fn from_base32(b32: &[u5]) -> Result<Self, Self::Err> {","class":"lineCov","hits":"1","order":"2337","possible_hits":"1",},
{"lineNum":"  162","line":"        convert_bits(b32, 5, 8, false)","class":"lineCov","hits":"1","order":"2338","possible_hits":"1",},
{"lineNum":"  163","line":"    }","class":"linePartCov","hits":"1","order":"2343","possible_hits":"2",},
{"lineNum":"  164","line":"}"},
{"lineNum":"  165","line":""},
{"lineNum":"  166","line":"impl<T: AsRef<[u8]>> ToBase32<Vec<u5>> for T {"},
{"lineNum":"  167","line":"    /// Convert base256 to base32, adds padding if necessary"},
{"lineNum":"  168","line":"    fn to_base32(&self) -> Vec<u5> {","class":"linePartCov","hits":"2","order":"2226","possible_hits":"3",},
{"lineNum":"  169","line":"        convert_bits(self.as_ref(), 8, 5, true).expect(","class":"linePartCov","hits":"2","order":"2227","possible_hits":"3",},
{"lineNum":"  170","line":"            \"both error conditions are impossible (InvalidPadding, InvalidData)\""},
{"lineNum":"  171","line":"        ).check_base32().expect("},
{"lineNum":"  172","line":"            \"after conversion all elements are in range\""},
{"lineNum":"  173","line":"        )"},
{"lineNum":"  174","line":"    }","class":"linePartCov","hits":"2","order":"2302","possible_hits":"6",},
{"lineNum":"  175","line":"}"},
{"lineNum":"  176","line":""},
{"lineNum":"  177","line":"impl Bech32 {"},
{"lineNum":"  178","line":"    /// Constructs a `Bech32` struct if the result can be encoded as a bech32 string."},
{"lineNum":"  179","line":"    ///"},
{"lineNum":"  180","line":"    /// # Errors"},
{"lineNum":"  181","line":"    /// * **MixedCase**: if the HRP contains upper case letters. Encoders must use lower case."},
{"lineNum":"  182","line":"    /// * **InvalidChar**: if the HRP contains any non-ASCII characters (outside 33..=126)"},
{"lineNum":"  183","line":"    /// * **InvalidLength**: if the HRP is outside 1..83 characters long"},
{"lineNum":"  184","line":"    ///"},
{"lineNum":"  185","line":"    /// # Deviations from standard"},
{"lineNum":"  186","line":"    /// * No length limits are enforced for the data part"},
{"lineNum":"  187","line":"    ///"},
{"lineNum":"  188","line":"    pub fn new(hrp: String, data: Vec<u5>) -> Result<Bech32, Error> {","class":"linePartCov","hits":"1","order":"2917","possible_hits":"2",},
{"lineNum":"  189","line":"        if hrp.is_empty() || hrp.len() > 83 {","class":"lineCov","hits":"3","order":"2918","possible_hits":"3",},
{"lineNum":"  190","line":"            return Err(Error::InvalidLength)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  191","line":"        }"},
{"lineNum":"  192","line":""},
{"lineNum":"  193","line":"        if let Some(c) = hrp.chars().find(|&c| (c as u32) < 33 || (c as u32) > 126) {","class":"lineCov","hits":"4","order":"2922","possible_hits":"4",},
{"lineNum":"  194","line":"            return Err(Error::InvalidChar(c));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  195","line":"        }"},
{"lineNum":"  196","line":""},
{"lineNum":"  197","line":"        if hrp.chars().any(|c| c.is_uppercase()) {","class":"lineCov","hits":"3","order":"2929","possible_hits":"3",},
{"lineNum":"  198","line":"            return Err(Error::MixedCase);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  199","line":"        }"},
{"lineNum":"  200","line":""},
{"lineNum":"  201","line":"        Ok(Bech32 {hrp: hrp, data: data})","class":"lineCov","hits":"1","order":"2943","possible_hits":"1",},
{"lineNum":"  202","line":"    }","class":"linePartCov","hits":"2","order":"2944","possible_hits":"3",},
{"lineNum":"  203","line":""},
{"lineNum":"  204","line":"    /// Constructs a `Bech32` struct if the result can be encoded as a bech32 string. It uses"},
{"lineNum":"  205","line":"    /// `data` that is not range checked yet and as a result may return `Err(Error::InvalidData)`."},
{"lineNum":"  206","line":"    ///"},
{"lineNum":"  207","line":"    /// This function currently allocates memory for the checked data part."},
{"lineNum":"  208","line":"    /// See [issue #19](https://github.com/rust-bitcoin/rust-bech32/issues/19)."},
{"lineNum":"  209","line":"    pub fn new_check_data(hrp: String, data: Vec<u8>) -> Result<Bech32, Error> {"},
{"lineNum":"  210","line":"        Self::new(hrp, data.check_base32()?)"},
{"lineNum":"  211","line":"    }"},
{"lineNum":"  212","line":""},
{"lineNum":"  213","line":"    /// Returns the human readable part"},
{"lineNum":"  214","line":"    pub fn hrp(&self) -> &str {"},
{"lineNum":"  215","line":"        &self.hrp"},
{"lineNum":"  216","line":"    }"},
{"lineNum":"  217","line":""},
{"lineNum":"  218","line":"    /// Returns the data part as `[u8]` but only using 5 bits per byte"},
{"lineNum":"  219","line":"    pub fn data(&self) -> &[u5] {"},
{"lineNum":"  220","line":"        &self.data"},
{"lineNum":"  221","line":"    }"},
{"lineNum":"  222","line":""},
{"lineNum":"  223","line":"    /// Destructures the `Bech32` struct into its parts"},
{"lineNum":"  224","line":"    pub fn into_parts(self) -> (String, Vec<u5>) {","class":"lineCov","hits":"1","order":"3466","possible_hits":"1",},
{"lineNum":"  225","line":"        (self.hrp, self.data)","class":"lineCov","hits":"1","order":"3467","possible_hits":"1",},
{"lineNum":"  226","line":"    }","class":"linePartCov","hits":"1","order":"3468","possible_hits":"2",},
{"lineNum":"  227","line":"}"},
{"lineNum":"  228","line":""},
{"lineNum":"  229","line":"impl Display for Bech32 {"},
{"lineNum":"  230","line":"    fn fmt(&self, f: &mut Formatter) -> fmt::Result {","class":"linePartCov","hits":"1","order":"2945","possible_hits":"2",},
{"lineNum":"  231","line":"        let hrp_bytes: &[u8] = self.hrp.as_bytes();","class":"lineCov","hits":"2","order":"2946","possible_hits":"2",},
{"lineNum":"  232","line":"        let checksum = create_checksum(hrp_bytes, &self.data);","class":"lineCov","hits":"1","order":"2947","possible_hits":"1",},
{"lineNum":"  233","line":"        let data_part = self.data.iter().chain(checksum.iter());","class":"lineCov","hits":"2","order":"3014","possible_hits":"2",},
{"lineNum":"  234","line":""},
{"lineNum":"  235","line":"        write!(","class":"lineCov","hits":"2","order":"3072","possible_hits":"2",},
{"lineNum":"  236","line":"            f,","class":"lineCov","hits":"1","order":"3021","possible_hits":"1",},
{"lineNum":"  237","line":"            \"{}{}{}\","},
{"lineNum":"  238","line":"            self.hrp,","class":"lineCov","hits":"1","order":"3022","possible_hits":"1",},
{"lineNum":"  239","line":"            SEP,"},
{"lineNum":"  240","line":"            data_part.map(|p| CHARSET[*p.as_ref() as usize]).collect::<String>()","class":"lineCov","hits":"3","order":"3023","possible_hits":"3",},
{"lineNum":"  241","line":"        )"},
{"lineNum":"  242","line":"    }","class":"linePartCov","hits":"1","order":"3077","possible_hits":"3",},
{"lineNum":"  243","line":"}"},
{"lineNum":"  244","line":""},
{"lineNum":"  245","line":"impl FromStr for Bech32 {"},
{"lineNum":"  246","line":"    type Err = Error;"},
{"lineNum":"  247","line":""},
{"lineNum":"  248","line":"    /// Decode from a string"},
{"lineNum":"  249","line":"    fn from_str(s: &str) -> Result<Bech32, Error> {","class":"linePartCov","hits":"1","order":"3255","possible_hits":"2",},
{"lineNum":"  250","line":"        // Ensure overall length is within bounds"},
{"lineNum":"  251","line":"        let len: usize = s.len();","class":"lineCov","hits":"1","order":"3256","possible_hits":"1",},
{"lineNum":"  252","line":"        if len < 8 {","class":"lineCov","hits":"1","order":"3257","possible_hits":"1",},
{"lineNum":"  253","line":"            return Err(Error::InvalidLength)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  254","line":"        }"},
{"lineNum":"  255","line":""},
{"lineNum":"  256","line":"        // Check for missing separator"},
{"lineNum":"  257","line":"        if s.find(SEP).is_none() {","class":"lineCov","hits":"2","order":"3258","possible_hits":"2",},
{"lineNum":"  258","line":"            return Err(Error::MissingSeparator)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  259","line":"        }"},
{"lineNum":"  260","line":""},
{"lineNum":"  261","line":"        // Split at separator and check for two pieces"},
{"lineNum":"  262","line":"        let parts: Vec<&str> = s.rsplitn(2, SEP).collect();","class":"lineCov","hits":"1","order":"3302","possible_hits":"1",},
{"lineNum":"  263","line":"        let raw_hrp = parts[1];","class":"lineCov","hits":"1","order":"3379","possible_hits":"1",},
{"lineNum":"  264","line":"        let raw_data = parts[0];","class":"lineCov","hits":"2","order":"3385","possible_hits":"2",},
{"lineNum":"  265","line":"        if raw_hrp.len() < 1 || raw_data.len() < 6 || raw_hrp.len() > 83 {","class":"lineCov","hits":"1","order":"3386","possible_hits":"1",},
{"lineNum":"  266","line":"            return Err(Error::InvalidLength)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  267","line":"        }"},
{"lineNum":"  268","line":""},
{"lineNum":"  269","line":"        let mut has_lower: bool = false;","class":"lineCov","hits":"1","order":"3387","possible_hits":"1",},
{"lineNum":"  270","line":"        let mut has_upper: bool = false;","class":"lineCov","hits":"1","order":"3388","possible_hits":"1",},
{"lineNum":"  271","line":"        let mut hrp_bytes: Vec<u8> = Vec::new();","class":"lineCov","hits":"1","order":"3389","possible_hits":"1",},
{"lineNum":"  272","line":"        for b in raw_hrp.bytes() {","class":"lineCov","hits":"3","order":"3390","possible_hits":"3",},
{"lineNum":"  273","line":"            // Valid subset of ASCII"},
{"lineNum":"  274","line":"            if b < 33 || b > 126 {","class":"linePartCov","hits":"1","order":"3411","possible_hits":"2",},
{"lineNum":"  275","line":"                return Err(Error::InvalidChar(b as char))","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  276","line":"            }"},
{"lineNum":"  277","line":"            let mut c = b;","class":"lineCov","hits":"1","order":"3412","possible_hits":"1",},
{"lineNum":"  278","line":"            // Lowercase"},
{"lineNum":"  279","line":"            if b >= b\'a\' && b <= b\'z\' {","class":"lineCov","hits":"2","order":"3413","possible_hits":"2",},
{"lineNum":"  280","line":"                has_lower = true;","class":"lineCov","hits":"1","order":"3414","possible_hits":"1",},
{"lineNum":"  281","line":"            }"},
{"lineNum":"  282","line":"            // Uppercase"},
{"lineNum":"  283","line":"            if b >= b\'A\' && b <= b\'Z\' {","class":"lineCov","hits":"1","order":"3415","possible_hits":"1",},
{"lineNum":"  284","line":"                has_upper = true;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  285","line":"                // Convert to lowercase"},
{"lineNum":"  286","line":"                c = b + (b\'a\'-b\'A\');","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  287","line":"            }"},
{"lineNum":"  288","line":"            hrp_bytes.push(c);","class":"lineCov","hits":"1","order":"3416","possible_hits":"1",},
{"lineNum":"  289","line":"        }"},
{"lineNum":"  290","line":""},
{"lineNum":"  291","line":"        // Check data payload"},
{"lineNum":"  292","line":"        let mut data_bytes = raw_data.chars().map(|c| {","class":"linePartCov","hits":"4","order":"3417","possible_hits":"5",},
{"lineNum":"  293","line":"            // Only check if c is in the ASCII range, all invalid ASCII characters have the value -1"},
{"lineNum":"  294","line":"            // in CHARSET_REV (which covers the whole ASCII range) and will be filtered out later."},
{"lineNum":"  295","line":"            if !c.is_ascii() {","class":"lineCov","hits":"1","order":"3418","possible_hits":"1",},
{"lineNum":"  296","line":"                return Err(Error::InvalidChar(c))","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  297","line":"            }"},
{"lineNum":"  298","line":""},
{"lineNum":"  299","line":"            if c.is_lowercase() {","class":"lineCov","hits":"4","order":"3422","possible_hits":"4",},
{"lineNum":"  300","line":"                has_lower = true;","class":"lineCov","hits":"1","order":"3427","possible_hits":"1",},
{"lineNum":"  301","line":"            } else if c.is_uppercase() {","class":"lineCov","hits":"1","order":"3438","possible_hits":"1",},
{"lineNum":"  302","line":"                has_upper = true;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  303","line":"            }"},
{"lineNum":"  304","line":""},
{"lineNum":"  305","line":"            // c should be <128 since it is in the ASCII range, CHARSET_REV.len() == 128"},
{"lineNum":"  306","line":"            let num_value = CHARSET_REV[c as usize];","class":"linePartCov","hits":"1","order":"3428","possible_hits":"3",},
{"lineNum":"  307","line":""},
{"lineNum":"  308","line":"            if num_value > 31 || num_value < 0 {","class":"lineCov","hits":"1","order":"3429","possible_hits":"1",},
{"lineNum":"  309","line":"                return Err(Error::InvalidChar(c));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  310","line":"            }"},
{"lineNum":"  311","line":""},
{"lineNum":"  312","line":"            Ok(u5::try_from_u8(num_value as u8).expect(\"range checked above, num_value <= 31\"))","class":"lineCov","hits":"1","order":"3430","possible_hits":"1",},
{"lineNum":"  313","line":"        }).collect::<Result<Vec<u5>, Error>>()?;","class":"linePartCov","hits":"3","order":"3431","possible_hits":"6",},
{"lineNum":"  314","line":""},
{"lineNum":"  315","line":"        // Ensure no mixed case"},
{"lineNum":"  316","line":"        if has_lower && has_upper {","class":"linePartCov","hits":"1","order":"3439","possible_hits":"2",},
{"lineNum":"  317","line":"            return Err(Error::MixedCase)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  318","line":"        }"},
{"lineNum":"  319","line":""},
{"lineNum":"  320","line":"        // Ensure checksum"},
{"lineNum":"  321","line":"        if !verify_checksum(&hrp_bytes, &data_bytes) {","class":"lineCov","hits":"2","order":"3440","possible_hits":"2",},
{"lineNum":"  322","line":"            return Err(Error::InvalidChecksum)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  323","line":"        }"},
{"lineNum":"  324","line":""},
{"lineNum":"  325","line":"        // Remove checksum from data payload"},
{"lineNum":"  326","line":"        let dbl: usize = data_bytes.len();","class":"lineCov","hits":"1","order":"3446","possible_hits":"1",},
{"lineNum":"  327","line":"        data_bytes.truncate(dbl - 6);","class":"linePartCov","hits":"1","order":"3447","possible_hits":"3",},
{"lineNum":"  328","line":""},
{"lineNum":"  329","line":"        Ok(Bech32 {","class":"lineCov","hits":"1","order":"3464","possible_hits":"1",},
{"lineNum":"  330","line":"            hrp: String::from_utf8(hrp_bytes).unwrap(),","class":"lineCov","hits":"1","order":"3460","possible_hits":"1",},
{"lineNum":"  331","line":"            data: data_bytes","class":"lineCov","hits":"1","order":"3463","possible_hits":"1",},
{"lineNum":"  332","line":"        })"},
{"lineNum":"  333","line":"    }","class":"linePartCov","hits":"2","order":"3465","possible_hits":"8",},
{"lineNum":"  334","line":"}"},
{"lineNum":"  335","line":""},
{"lineNum":"  336","line":"fn create_checksum(hrp: &[u8], data: &[u5]) -> Vec<u5> {","class":"linePartCov","hits":"1","order":"2948","possible_hits":"2",},
{"lineNum":"  337","line":"    let mut values: Vec<u5> = hrp_expand(hrp);","class":"lineCov","hits":"1","order":"2949","possible_hits":"1",},
{"lineNum":"  338","line":"    values.extend_from_slice(data);","class":"lineCov","hits":"1","order":"2959","possible_hits":"1",},
{"lineNum":"  339","line":"    // Pad with 6 zeros"},
{"lineNum":"  340","line":"    values.extend_from_slice(&[u5::try_from_u8(0).unwrap(); 6]);","class":"lineCov","hits":"2","order":"2960","possible_hits":"2",},
{"lineNum":"  341","line":"    let plm: u32 = polymod(&values) ^ 1;","class":"lineCov","hits":"1","order":"2961","possible_hits":"1",},
{"lineNum":"  342","line":"    let mut checksum: Vec<u5> = Vec::new();","class":"lineCov","hits":"1","order":"2997","possible_hits":"1",},
{"lineNum":"  343","line":"    for p in 0..6 {","class":"lineCov","hits":"4","order":"2998","possible_hits":"4",},
{"lineNum":"  344","line":"        checksum.push(u5::try_from_u8(((plm >> (5 * (5 - p))) & 0x1f) as u8).unwrap());","class":"linePartCov","hits":"2","order":"3011","possible_hits":"3",},
{"lineNum":"  345","line":"    }"},
{"lineNum":"  346","line":"    checksum","class":"lineCov","hits":"1","order":"3012","possible_hits":"1",},
{"lineNum":"  347","line":"}","class":"linePartCov","hits":"2","order":"3013","possible_hits":"5",},
{"lineNum":"  348","line":""},
{"lineNum":"  349","line":"fn verify_checksum(hrp: &[u8], data: &[u5]) -> bool {","class":"linePartCov","hits":"1","order":"3441","possible_hits":"2",},
{"lineNum":"  350","line":"    let mut exp = hrp_expand(hrp);","class":"lineCov","hits":"1","order":"3442","possible_hits":"1",},
{"lineNum":"  351","line":"    exp.extend_from_slice(data);","class":"lineCov","hits":"1","order":"3443","possible_hits":"1",},
{"lineNum":"  352","line":"    polymod(&exp) == 1u32","class":"lineCov","hits":"2","order":"3444","possible_hits":"2",},
{"lineNum":"  353","line":"}","class":"linePartCov","hits":"1","order":"3445","possible_hits":"2",},
{"lineNum":"  354","line":""},
{"lineNum":"  355","line":"fn hrp_expand(hrp: &[u8]) -> Vec<u5> {","class":"linePartCov","hits":"1","order":"2950","possible_hits":"2",},
{"lineNum":"  356","line":"    let mut v: Vec<u5> = Vec::new();","class":"lineCov","hits":"1","order":"2951","possible_hits":"1",},
{"lineNum":"  357","line":"    for b in hrp {","class":"lineCov","hits":"4","order":"2952","possible_hits":"4",},
{"lineNum":"  358","line":"        v.push(u5::try_from_u8(*b >> 5).expect(\"can\'t be out of range, max. 7\"));","class":"lineCov","hits":"2","order":"2953","possible_hits":"2",},
{"lineNum":"  359","line":"    }"},
{"lineNum":"  360","line":"    v.push(u5::try_from_u8(0).unwrap());","class":"lineCov","hits":"2","order":"2954","possible_hits":"2",},
{"lineNum":"  361","line":"    for b in hrp {","class":"lineCov","hits":"2","order":"2955","possible_hits":"2",},
{"lineNum":"  362","line":"        v.push(u5::try_from_u8(*b & 0x1f).expect(\"can\'t be out of range, max. 31\"));","class":"lineCov","hits":"2","order":"2956","possible_hits":"2",},
{"lineNum":"  363","line":"    }"},
{"lineNum":"  364","line":"    v","class":"lineCov","hits":"1","order":"2957","possible_hits":"1",},
{"lineNum":"  365","line":"}","class":"linePartCov","hits":"1","order":"2958","possible_hits":"3",},
{"lineNum":"  366","line":""},
{"lineNum":"  367","line":"fn polymod(values: &[u5]) -> u32 {","class":"lineCov","hits":"1","order":"2962","possible_hits":"1",},
{"lineNum":"  368","line":"    let mut chk: u32 = 1;","class":"lineCov","hits":"1","order":"2963","possible_hits":"1",},
{"lineNum":"  369","line":"    let mut b: u8;"},
{"lineNum":"  370","line":"    for v in values {","class":"lineCov","hits":"3","order":"2964","possible_hits":"3",},
{"lineNum":"  371","line":"        b = (chk >> 25) as u8;","class":"lineCov","hits":"2","order":"2965","possible_hits":"2",},
{"lineNum":"  372","line":"        chk = (chk & 0x1ffffff) << 5 ^ (u32::from(*v.as_ref()));","class":"lineCov","hits":"1","order":"2966","possible_hits":"1",},
{"lineNum":"  373","line":"        for i in 0..5 {","class":"lineCov","hits":"2","order":"2970","possible_hits":"2",},
{"lineNum":"  374","line":"            if (b >> i) & 1 == 1 {","class":"linePartCov","hits":"2","order":"2993","possible_hits":"3",},
{"lineNum":"  375","line":"                chk ^= GEN[i]","class":"linePartCov","hits":"1","order":"2994","possible_hits":"3",},
{"lineNum":"  376","line":"            }"},
{"lineNum":"  377","line":"        }"},
{"lineNum":"  378","line":"    }"},
{"lineNum":"  379","line":"    chk","class":"lineCov","hits":"1","order":"2995","possible_hits":"1",},
{"lineNum":"  380","line":"}","class":"linePartCov","hits":"1","order":"2996","possible_hits":"2",},
{"lineNum":"  381","line":""},
{"lineNum":"  382","line":"/// Human-readable part and data part separator"},
{"lineNum":"  383","line":"const SEP: char = \'1\';"},
{"lineNum":"  384","line":""},
{"lineNum":"  385","line":"/// Encoding character set. Maps data value -> char"},
{"lineNum":"  386","line":"const CHARSET: [char; 32] = ["},
{"lineNum":"  387","line":"    \'q\',\'p\',\'z\',\'r\',\'y\',\'9\',\'x\',\'8\',"},
{"lineNum":"  388","line":"    \'g\',\'f\',\'2\',\'t\',\'v\',\'d\',\'w\',\'0\',"},
{"lineNum":"  389","line":"    \'s\',\'3\',\'j\',\'n\',\'5\',\'4\',\'k\',\'h\',"},
{"lineNum":"  390","line":"    \'c\',\'e\',\'6\',\'m\',\'u\',\'a\',\'7\',\'l\'"},
{"lineNum":"  391","line":"];"},
{"lineNum":"  392","line":""},
{"lineNum":"  393","line":"// Reverse character set. Maps ASCII byte -> CHARSET index on [0,31]"},
{"lineNum":"  394","line":"const CHARSET_REV: [i8; 128] = ["},
{"lineNum":"  395","line":"    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,"},
{"lineNum":"  396","line":"    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,"},
{"lineNum":"  397","line":"    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,"},
{"lineNum":"  398","line":"    15, -1, 10, 17, 21, 20, 26, 30,  7,  5, -1, -1, -1, -1, -1, -1,"},
{"lineNum":"  399","line":"    -1, 29, -1, 24, 13, 25,  9,  8, 23, -1, 18, 22, 31, 27, 19, -1,"},
{"lineNum":"  400","line":"     1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1,"},
{"lineNum":"  401","line":"    -1, 29, -1, 24, 13, 25,  9,  8, 23, -1, 18, 22, 31, 27, 19, -1,"},
{"lineNum":"  402","line":"     1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1"},
{"lineNum":"  403","line":"];"},
{"lineNum":"  404","line":""},
{"lineNum":"  405","line":"/// Generator coefficients"},
{"lineNum":"  406","line":"const GEN: [u32; 5] = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];"},
{"lineNum":"  407","line":""},
{"lineNum":"  408","line":"/// Error types for Bech32 encoding / decoding"},
{"lineNum":"  409","line":"#[derive(Copy, Clone, PartialEq, Debug)]","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  410","line":"pub enum Error {"},
{"lineNum":"  411","line":"    /// String does not contain the separator character"},
{"lineNum":"  412","line":"    MissingSeparator,"},
{"lineNum":"  413","line":"    /// The checksum does not match the rest of the data"},
{"lineNum":"  414","line":"    InvalidChecksum,"},
{"lineNum":"  415","line":"    /// The data or human-readable part is too long or too short"},
{"lineNum":"  416","line":"    InvalidLength,"},
{"lineNum":"  417","line":"    /// Some part of the string contains an invalid character"},
{"lineNum":"  418","line":"    InvalidChar(char),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  419","line":"    /// Some part of the data has an invalid value"},
{"lineNum":"  420","line":"    InvalidData(u8),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  421","line":"    /// The bit conversion failed due to a padding issue"},
{"lineNum":"  422","line":"    InvalidPadding,"},
{"lineNum":"  423","line":"    /// The whole string must be of one case"},
{"lineNum":"  424","line":"    MixedCase,"},
{"lineNum":"  425","line":"}"},
{"lineNum":"  426","line":""},
{"lineNum":"  427","line":"impl fmt::Display for Error {"},
{"lineNum":"  428","line":"    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"},
{"lineNum":"  429","line":"        match *self {"},
{"lineNum":"  430","line":"            Error::MissingSeparator => write!(f, \"missing human-readable separator, \\\"{}\\\"\", SEP),"},
{"lineNum":"  431","line":"            Error::InvalidChecksum => write!(f, \"invalid checksum\"),"},
{"lineNum":"  432","line":"            Error::InvalidLength => write!(f, \"invalid length\"),"},
{"lineNum":"  433","line":"            Error::InvalidChar(n) => write!(f, \"invalid character (code={})\", n),"},
{"lineNum":"  434","line":"            Error::InvalidData(n) => write!(f, \"invalid data point ({})\", n),"},
{"lineNum":"  435","line":"            Error::InvalidPadding => write!(f, \"invalid padding\"),"},
{"lineNum":"  436","line":"            Error::MixedCase => write!(f, \"mixed-case strings not allowed\"),"},
{"lineNum":"  437","line":"        }"},
{"lineNum":"  438","line":"    }"},
{"lineNum":"  439","line":"}"},
{"lineNum":"  440","line":""},
{"lineNum":"  441","line":"impl error::Error for Error {"},
{"lineNum":"  442","line":"    fn description(&self) -> &str {"},
{"lineNum":"  443","line":"        match *self {"},
{"lineNum":"  444","line":"            Error::MissingSeparator => \"missing human-readable separator\","},
{"lineNum":"  445","line":"            Error::InvalidChecksum => \"invalid checksum\","},
{"lineNum":"  446","line":"            Error::InvalidLength => \"invalid length\","},
{"lineNum":"  447","line":"            Error::InvalidChar(_) => \"invalid character\","},
{"lineNum":"  448","line":"            Error::InvalidData(_) => \"invalid data point\","},
{"lineNum":"  449","line":"            Error::InvalidPadding => \"invalid padding\","},
{"lineNum":"  450","line":"            Error::MixedCase => \"mixed-case strings not allowed\","},
{"lineNum":"  451","line":"        }"},
{"lineNum":"  452","line":"    }"},
{"lineNum":"  453","line":"}"},
{"lineNum":"  454","line":""},
{"lineNum":"  455","line":"/// Convert between bit sizes"},
{"lineNum":"  456","line":"///"},
{"lineNum":"  457","line":"/// # Errors"},
{"lineNum":"  458","line":"/// * `Error::InvalidData` if any element of `data` is out of range"},
{"lineNum":"  459","line":"/// * `Error::InvalidPadding` if `pad == false` and the padding bits are not `0`"},
{"lineNum":"  460","line":"///"},
{"lineNum":"  461","line":"/// # Panics"},
{"lineNum":"  462","line":"/// Function will panic if attempting to convert `from` or `to` a bit size that"},
{"lineNum":"  463","line":"/// is 0 or larger than 8 bits."},
{"lineNum":"  464","line":"///"},
{"lineNum":"  465","line":"/// # Examples"},
{"lineNum":"  466","line":"///"},
{"lineNum":"  467","line":"/// ```rust"},
{"lineNum":"  468","line":"/// use bech32::convert_bits;"},
{"lineNum":"  469","line":"/// let base5 = convert_bits(&[0xff], 8, 5, true);"},
{"lineNum":"  470","line":"/// assert_eq!(base5.unwrap(), vec![0x1f, 0x1c]);"},
{"lineNum":"  471","line":"/// ```"},
{"lineNum":"  472","line":"pub fn convert_bits<T>(data: &[T], from: u32, to: u32, pad: bool) -> Result<Vec<u8>, Error>","class":"linePartCov","hits":"2","order":"2233","possible_hits":"4",},
{"lineNum":"  473","line":"    where T: Into<u8> + Copy"},
{"lineNum":"  474","line":"{"},
{"lineNum":"  475","line":"    if from > 8 || to > 8 || from == 0 || to == 0 {","class":"lineCov","hits":"2","order":"2234","possible_hits":"2",},
{"lineNum":"  476","line":"        panic!(\"convert_bits `from` and `to` parameters 0 or greater than 8\");","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  477","line":"    }"},
{"lineNum":"  478","line":"    let mut acc: u32 = 0;","class":"lineCov","hits":"2","order":"2235","possible_hits":"2",},
{"lineNum":"  479","line":"    let mut bits: u32 = 0;","class":"lineCov","hits":"2","order":"2236","possible_hits":"2",},
{"lineNum":"  480","line":"    let mut ret: Vec<u8> = Vec::new();","class":"lineCov","hits":"2","order":"2237","possible_hits":"2",},
{"lineNum":"  481","line":"    let maxv: u32 = (1<<to) - 1;","class":"linePartCov","hits":"4","order":"2238","possible_hits":"6",},
{"lineNum":"  482","line":"    for value in data {","class":"lineCov","hits":"6","order":"2239","possible_hits":"6",},
{"lineNum":"  483","line":"        let v: u32 = u32::from(Into::<u8>::into(*value));","class":"lineCov","hits":"4","order":"2243","possible_hits":"4",},
{"lineNum":"  484","line":"        if (v >> from) != 0 {","class":"linePartCov","hits":"2","order":"2248","possible_hits":"4",},
{"lineNum":"  485","line":"            // Input value exceeds `from` bit size"},
{"lineNum":"  486","line":"            return Err(Error::InvalidData(v as u8))","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  487","line":"        }"},
{"lineNum":"  488","line":"        acc = (acc << from) | v;","class":"linePartCov","hits":"4","order":"2249","possible_hits":"6",},
{"lineNum":"  489","line":"        bits += from;","class":"linePartCov","hits":"2","order":"2250","possible_hits":"4",},
{"lineNum":"  490","line":"        while bits >= to {","class":"lineCov","hits":"4","order":"2251","possible_hits":"4",},
{"lineNum":"  491","line":"            bits -= to;","class":"linePartCov","hits":"2","order":"2252","possible_hits":"4",},
{"lineNum":"  492","line":"            ret.push(((acc >> bits) & maxv) as u8);","class":"linePartCov","hits":"2","order":"2253","possible_hits":"4",},
{"lineNum":"  493","line":"        }"},
{"lineNum":"  494","line":"    }"},
{"lineNum":"  495","line":"    if pad {","class":"linePartCov","hits":"4","order":"2255","possible_hits":"6",},
{"lineNum":"  496","line":"        if bits > 0 {","class":"linePartCov","hits":"2","order":"2256","possible_hits":"4",},
{"lineNum":"  497","line":"            ret.push(((acc << (to - bits)) & maxv) as u8);","class":"linePartCov","hits":"1","order":"2257","possible_hits":"4",},
{"lineNum":"  498","line":"        }"},
{"lineNum":"  499","line":"    } else if bits >= from || ((acc << (to - bits)) & maxv) != 0 {","class":"linePartCov","hits":"1","order":"2342","possible_hits":"6",},
{"lineNum":"  500","line":"        return Err(Error::InvalidPadding)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  501","line":"    }"},
{"lineNum":"  502","line":"    Ok(ret)","class":"lineCov","hits":"2","order":"2258","possible_hits":"2",},
{"lineNum":"  503","line":"}","class":"linePartCov","hits":"4","order":"2259","possible_hits":"8",},
{"lineNum":"  504","line":""},
{"lineNum":"  505","line":"#[cfg(test)]"},
{"lineNum":"  506","line":"mod tests {"},
{"lineNum":"  507","line":"    use Bech32;"},
{"lineNum":"  508","line":"    use Error;"},
{"lineNum":"  509","line":"    use convert_bits;"},
{"lineNum":"  510","line":"    use CheckBase32;"},
{"lineNum":"  511","line":""},
{"lineNum":"  512","line":"    #[test]"},
{"lineNum":"  513","line":"    fn new_checks() {"},
{"lineNum":"  514","line":"        assert!(Bech32::new_check_data(\"test\".into(), vec![1, 2, 3, 4]).is_ok());"},
{"lineNum":"  515","line":"        assert_eq!(Bech32::new_check_data(\"\".into(), vec![1, 2, 3, 4]), Err(Error::InvalidLength));"},
{"lineNum":"  516","line":"        assert_eq!(Bech32::new_check_data(\"test\".into(), vec![30, 31, 35, 20]), Err(Error::InvalidData(35)));"},
{"lineNum":"  517","line":""},
{"lineNum":"  518","line":"        let both = Bech32::new_check_data(\"\".into(), vec![30, 31, 35, 20]);"},
{"lineNum":"  519","line":"        assert!(both == Err(Error::InvalidLength) || both == Err(Error::InvalidData(35)));"},
{"lineNum":"  520","line":""},
{"lineNum":"  521","line":"        assert!(Bech32::new(\"test\".into(), [1u8, 2, 3, 4].check_base32().unwrap()).is_ok());"},
{"lineNum":"  522","line":"        assert_eq!(Bech32::new(\"\".into(), [1u8, 2, 3, 4].check_base32().unwrap()), Err(Error::InvalidLength));"},
{"lineNum":"  523","line":"    }"},
{"lineNum":"  524","line":""},
{"lineNum":"  525","line":"    #[test]"},
{"lineNum":"  526","line":"    fn getters() {"},
{"lineNum":"  527","line":"        let bech: Bech32 = \"BC1SW50QA3JX3S\".parse().unwrap();"},
{"lineNum":"  528","line":"        let data = [16, 14, 20, 15, 0].check_base32().unwrap();"},
{"lineNum":"  529","line":"        assert_eq!(bech.hrp(), \"bc\");"},
{"lineNum":"  530","line":"        assert_eq!("},
{"lineNum":"  531","line":"            bech.data(),"},
{"lineNum":"  532","line":"            data.as_slice()"},
{"lineNum":"  533","line":"        );"},
{"lineNum":"  534","line":"        assert_eq!(bech.into_parts(), (\"bc\".to_owned(), data));"},
{"lineNum":"  535","line":"    }"},
{"lineNum":"  536","line":""},
{"lineNum":"  537","line":"    #[test]"},
{"lineNum":"  538","line":"    fn valid_checksum() {"},
{"lineNum":"  539","line":"        let strings: Vec<&str> = vec!("},
{"lineNum":"  540","line":"            \"A12UEL5L\","},
{"lineNum":"  541","line":"            \"an83characterlonghumanreadablepartthatcontainsthenumber1andtheexcludedcharactersbio1tt5tgs\","},
{"lineNum":"  542","line":"            \"abcdef1qpzry9x8gf2tvdw0s3jn54khce6mua7lmqqqxw\","},
{"lineNum":"  543","line":"            \"11qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqc8247j\","},
{"lineNum":"  544","line":"            \"split1checkupstagehandshakeupstreamerranterredcaperred2y9e3w\","},
{"lineNum":"  545","line":"        );"},
{"lineNum":"  546","line":"        for s in strings {"},
{"lineNum":"  547","line":"            let decode_result = s.parse::<Bech32>();"},
{"lineNum":"  548","line":"            if !decode_result.is_ok() {"},
{"lineNum":"  549","line":"                panic!(\"Did not decode: {:?} Reason: {:?}\", s, decode_result.unwrap_err());"},
{"lineNum":"  550","line":"            }"},
{"lineNum":"  551","line":"            assert!(decode_result.is_ok());"},
{"lineNum":"  552","line":"            let encode_result = decode_result.unwrap().to_string();"},
{"lineNum":"  553","line":"            assert_eq!(s.to_lowercase(), encode_result.to_lowercase());"},
{"lineNum":"  554","line":"        }"},
{"lineNum":"  555","line":"    }"},
{"lineNum":"  556","line":""},
{"lineNum":"  557","line":"    #[test]"},
{"lineNum":"  558","line":"    fn invalid_strings() {"},
{"lineNum":"  559","line":"        let pairs: Vec<(&str, Error)> = vec!("},
{"lineNum":"  560","line":"            (\" 1nwldj5\","},
{"lineNum":"  561","line":"                Error::InvalidChar(\' \')),"},
{"lineNum":"  562","line":"            (\"abc1\\u{2192}axkwrx\","},
{"lineNum":"  563","line":"                Error::InvalidChar(\'\\u{2192}\')),"},
{"lineNum":"  564","line":"            (\"an84characterslonghumanreadablepartthatcontainsthenumber1andtheexcludedcharactersbio1569pvx\","},
{"lineNum":"  565","line":"                Error::InvalidLength),"},
{"lineNum":"  566","line":"            (\"pzry9x0s0muk\","},
{"lineNum":"  567","line":"                Error::MissingSeparator),"},
{"lineNum":"  568","line":"            (\"1pzry9x0s0muk\","},
{"lineNum":"  569","line":"                Error::InvalidLength),"},
{"lineNum":"  570","line":"            (\"x1b4n0q5v\","},
{"lineNum":"  571","line":"                Error::InvalidChar(\'b\')),"},
{"lineNum":"  572","line":"            (\"ABC1DEFGOH\","},
{"lineNum":"  573","line":"                Error::InvalidChar(\'O\')),"},
{"lineNum":"  574","line":"            (\"li1dgmt3\","},
{"lineNum":"  575","line":"                Error::InvalidLength),"},
{"lineNum":"  576","line":"            (\"de1lg7wt\\u{ff}\","},
{"lineNum":"  577","line":"                Error::InvalidChar(\'\\u{ff}\')),"},
{"lineNum":"  578","line":"        );"},
{"lineNum":"  579","line":"        for p in pairs {"},
{"lineNum":"  580","line":"            let (s, expected_error) = p;"},
{"lineNum":"  581","line":"            let dec_result = s.parse::<Bech32>();"},
{"lineNum":"  582","line":"            if dec_result.is_ok() {"},
{"lineNum":"  583","line":"                println!(\"{:?}\", dec_result.unwrap());"},
{"lineNum":"  584","line":"                panic!(\"Should be invalid: {:?}\", s);"},
{"lineNum":"  585","line":"            }"},
{"lineNum":"  586","line":"            assert_eq!(dec_result.unwrap_err(), expected_error, \"testing input \'{}\'\", s);"},
{"lineNum":"  587","line":"        }"},
{"lineNum":"  588","line":"    }"},
{"lineNum":"  589","line":""},
{"lineNum":"  590","line":"    #[test]"},
{"lineNum":"  591","line":"    fn valid_conversion() {"},
{"lineNum":"  592","line":"        // Set of [data, from_bits, to_bits, pad, result]"},
{"lineNum":"  593","line":"        let tests: Vec<(Vec<u8>, u32, u32, bool, Vec<u8>)> = vec!("},
{"lineNum":"  594","line":"            (vec![0x01], 1, 1, true, vec![0x01]),"},
{"lineNum":"  595","line":"            (vec![0x01, 0x01], 1, 1, true, vec![0x01, 0x01]),"},
{"lineNum":"  596","line":"            (vec![0x01], 8, 8, true, vec![0x01]),"},
{"lineNum":"  597","line":"            (vec![0x01], 8, 4, true, vec![0x00, 0x01]),"},
{"lineNum":"  598","line":"            (vec![0x01], 8, 2, true, vec![0x00, 0x00, 0x00, 0x01]),"},
{"lineNum":"  599","line":"            (vec![0x01], 8, 1, true, vec![0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01]),"},
{"lineNum":"  600","line":"            (vec![0xff], 8, 5, true, vec![0x1f, 0x1c]),"},
{"lineNum":"  601","line":"            (vec![0x1f, 0x1c], 5, 8, false, vec![0xff]),"},
{"lineNum":"  602","line":"        );"},
{"lineNum":"  603","line":"        for t in tests {"},
{"lineNum":"  604","line":"            let (data, from_bits, to_bits, pad, expected_result) = t;"},
{"lineNum":"  605","line":"            let result = convert_bits(&data, from_bits, to_bits, pad);"},
{"lineNum":"  606","line":"            assert!(result.is_ok());"},
{"lineNum":"  607","line":"            assert_eq!(result.unwrap(), expected_result);"},
{"lineNum":"  608","line":"        }"},
{"lineNum":"  609","line":"    }"},
{"lineNum":"  610","line":""},
{"lineNum":"  611","line":"    #[test]"},
{"lineNum":"  612","line":"    fn invalid_conversion() {"},
{"lineNum":"  613","line":"        // Set of [data, from_bits, to_bits, pad, expected error]"},
{"lineNum":"  614","line":"        let tests: Vec<(Vec<u8>, u32, u32, bool, Error)> = vec!("},
{"lineNum":"  615","line":"            (vec![0xff], 8, 5, false, Error::InvalidPadding),"},
{"lineNum":"  616","line":"            (vec![0x02], 1, 1, true, Error::InvalidData(0x02)),"},
{"lineNum":"  617","line":"        );"},
{"lineNum":"  618","line":"        for t in tests {"},
{"lineNum":"  619","line":"            let (data, from_bits, to_bits, pad, expected_error) = t;"},
{"lineNum":"  620","line":"            let result = convert_bits(&data, from_bits, to_bits, pad);"},
{"lineNum":"  621","line":"            assert!(result.is_err());"},
{"lineNum":"  622","line":"            assert_eq!(result.unwrap_err(), expected_error);"},
{"lineNum":"  623","line":"        }"},
{"lineNum":"  624","line":"    }"},
{"lineNum":"  625","line":""},
{"lineNum":"  626","line":"    #[test]"},
{"lineNum":"  627","line":"    fn convert_bits_invalid_bit_size() {"},
{"lineNum":"  628","line":"        use std::panic::{catch_unwind, set_hook, take_hook};"},
{"lineNum":"  629","line":""},
{"lineNum":"  630","line":"        let invalid = &[(0, 8), (5, 0), (9, 5), (8, 10), (0, 16)];"},
{"lineNum":"  631","line":""},
{"lineNum":"  632","line":"        for &(from, to) in invalid {"},
{"lineNum":"  633","line":"            set_hook(Box::new(|_| {}));"},
{"lineNum":"  634","line":"            let result = catch_unwind(|| {"},
{"lineNum":"  635","line":"                let _ = convert_bits(&[0], from, to, true);"},
{"lineNum":"  636","line":"            });"},
{"lineNum":"  637","line":"            take_hook();"},
{"lineNum":"  638","line":"            assert!(result.is_err());"},
{"lineNum":"  639","line":"        }"},
{"lineNum":"  640","line":"    }"},
{"lineNum":"  641","line":""},
{"lineNum":"  642","line":"    #[test]"},
{"lineNum":"  643","line":"    fn check_base32() {"},
{"lineNum":"  644","line":"        assert!([0u8, 1, 2, 30, 31].check_base32().is_ok());"},
{"lineNum":"  645","line":"        assert!([0u8, 1, 2, 30, 31, 32].check_base32().is_err());"},
{"lineNum":"  646","line":"        assert!([0u8, 1, 2, 30, 31, 255].check_base32().is_err());"},
{"lineNum":"  647","line":"    }"},
{"lineNum":"  648","line":""},
{"lineNum":"  649","line":"    #[test]"},
{"lineNum":"  650","line":"    fn from_base32() {"},
{"lineNum":"  651","line":"        use FromBase32;"},
{"lineNum":"  652","line":"        assert_eq!(Vec::from_base32(&[0x1f, 0x1c].check_base32().unwrap()), Ok(vec![0xff]));"},
{"lineNum":"  653","line":"        assert_eq!("},
{"lineNum":"  654","line":"            Vec::from_base32(&[0x1f, 0x1f].check_base32().unwrap()),"},
{"lineNum":"  655","line":"            Err(Error::InvalidPadding)"},
{"lineNum":"  656","line":"        );"},
{"lineNum":"  657","line":"    }"},
{"lineNum":"  658","line":""},
{"lineNum":"  659","line":"    #[test]"},
{"lineNum":"  660","line":"    fn to_base32() {"},
{"lineNum":"  661","line":"        use ToBase32;"},
{"lineNum":"  662","line":"        assert_eq!([0xffu8].to_base32(), [0x1f, 0x1c].check_base32().unwrap());"},
{"lineNum":"  663","line":"    }"},
{"lineNum":"  664","line":""},
{"lineNum":"  665","line":"    #[test]"},
{"lineNum":"  666","line":"    fn reverse_charset() {"},
{"lineNum":"  667","line":"        // AsciiExt is needed for Rust 1.14 but not for newer versions"},
{"lineNum":"  668","line":"        #[allow(unused_imports, deprecated)]"},
{"lineNum":"  669","line":"        use std::ascii::AsciiExt;"},
{"lineNum":"  670","line":"        use ::CHARSET_REV;"},
{"lineNum":"  671","line":""},
{"lineNum":"  672","line":"        fn get_char_value(c: char) -> i8 {"},
{"lineNum":"  673","line":"            let charset = \"qpzry9x8gf2tvdw0s3jn54khce6mua7l\";"},
{"lineNum":"  674","line":"            match charset.find(c.to_ascii_lowercase()) {"},
{"lineNum":"  675","line":"                Some(x) => x as i8,"},
{"lineNum":"  676","line":"                None => -1,"},
{"lineNum":"  677","line":"            }"},
{"lineNum":"  678","line":"        }"},
{"lineNum":"  679","line":""},
{"lineNum":"  680","line":"        let expected_rev_charset = (0u8..128).map(|i| {"},
{"lineNum":"  681","line":"            get_char_value(i as char)"},
{"lineNum":"  682","line":"        }).collect::<Vec<_>>();"},
{"lineNum":"  683","line":""},
{"lineNum":"  684","line":"        assert_eq!(&(CHARSET_REV[..]), expected_rev_charset.as_slice());"},
{"lineNum":"  685","line":"    }"},
{"lineNum":"  686","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "ser_de-ab20411a83224715", "date" : "2019-06-01 07:50:29", "instrumented" : 153, "covered" : 131,};
var merged_data = [];
